package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.74

import (
	"context"
	"strconv"

	"github.com/cesaraugstz/comrade-notes/api/internal/auth"
	"github.com/cesaraugstz/comrade-notes/api/internal/database"
)

// CreateWishlist is the resolver for the createWishlist field.
func (r *mutationResolver) CreateWishlist(ctx context.Context, input CreateWishlistInput) (*MutationResponse, error) {
	userID := getUserIDFromContext(ctx)
	if userID == 0 {
		return &MutationResponse{Success: false, Message: stringPtr("unauthorized")}, nil
	}

	var categoryID *uint
	if input.CategoryID != nil {
		id, err := strconv.ParseUint(*input.CategoryID, 10, 32)
		if err != nil {
			return &MutationResponse{Success: false, Message: stringPtr("invalid category ID")}, nil
		}
		categoryID = uintPtr(uint(id))
	}

	wishlist := &database.Wishlist{
		Name:        input.Name,
		Description: stringValue(input.Description),
		CategoryID:  categoryID,
		OwnerID:     userID,
	}

	if err := r.DB.WithContext(ctx).Create(wishlist).Error; err != nil {
		return &MutationResponse{Success: false, Message: stringPtr("failed to create wishlist")}, nil
	}

	return &MutationResponse{Success: true}, nil
}

// CreateWishlistItem is the resolver for the createWishlistItem field.
func (r *mutationResolver) CreateWishlistItem(ctx context.Context, input CreateWishlistItemInput) (*MutationResponse, error) {
	wishlistID, err := strconv.ParseUint(input.WishlistID, 10, 32)
	if err != nil {
		return &MutationResponse{Success: false, Message: stringPtr("invalid wishlist ID")}, nil
	}

	var categoryID *uint
	if input.CategoryID != nil {
		id, err := strconv.ParseUint(*input.CategoryID, 10, 32)
		if err != nil {
			return &MutationResponse{Success: false, Message: stringPtr("invalid category ID")}, nil
		}
		categoryID = uintPtr(uint(id))
	}

	item := &database.WishlistItem{
		Name:        input.Name,
		Description: stringValue(input.Description),
		CategoryID:  categoryID,
		Rating:      input.Rating,
		WishlistID:  uint(wishlistID),
	}

	if err := r.DB.WithContext(ctx).Create(item).Error; err != nil {
		return &MutationResponse{Success: false, Message: stringPtr("failed to create item")}, nil
	}

	return &MutationResponse{Success: true}, nil
}

// CreateLink is the resolver for the createLink field.
func (r *mutationResolver) CreateLink(ctx context.Context, input CreateLinkInput) (*MutationResponse, error) {
	itemID, err := strconv.ParseUint(input.WishlistItemID, 10, 32)
	if err != nil {
		return &MutationResponse{Success: false, Message: stringPtr("invalid item ID")}, nil
	}

	link := &database.Link{
		URL:            input.URL,
		Title:          stringValue(input.Title),
		Price:          input.Price,
		WishlistItemID: uint(itemID),
	}

	if err := r.DB.WithContext(ctx).Create(link).Error; err != nil {
		return &MutationResponse{Success: false, Message: stringPtr("failed to create link")}, nil
	}

	return &MutationResponse{Success: true}, nil
}

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, input CreateCategoryInput) (*MutationResponse, error) {
	category := &database.Category{Name: input.Name}

	if err := r.DB.WithContext(ctx).Create(category).Error; err != nil {
		return &MutationResponse{Success: false, Message: stringPtr("failed to create category")}, nil
	}

	return &MutationResponse{Success: true}, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input CreateUserInput) (*MutationResponse, error) {
	var exists bool
	err := r.DB.WithContext(ctx).
		Model(&database.User{}).
		Select("1").
		Where("email = ?", input.Email).
		First(&exists).Error

	if err == nil {
		return &MutationResponse{Success: false, Message: stringPtr("user already exists")}, nil
	}

	hashed_password, err := auth.HashPassword(input.Password)

	if err != nil {
		return &MutationResponse{Success: false, Message: stringPtr("error while hashing the password")}, nil
	}

	user := &database.User{
		Email:    input.Email,
		Name:     input.Name,
		Password: hashed_password,
	}

	if err := r.DB.WithContext(ctx).Create(user).Error; err != nil {
		return &MutationResponse{Success: false, Message: stringPtr("failed to create user")}, nil
	}

	return &MutationResponse{Success: true}, nil
}

// Wishlists is the resolver for the wishlists field.
func (r *queryResolver) Wishlists(ctx context.Context) ([]*Wishlist, error) {
	userID := getUserIDFromContext(ctx)
	if userID == 0 {
		return nil, nil
	}

	var dbWishlists []database.Wishlist
	err := r.DB.WithContext(ctx).
		Preload("Category").
		Preload("Owner").
		Preload("Items.Category").
		Preload("Items.Links").
		Where("owner_id = ?", userID).
		Find(&dbWishlists).Error

	if err != nil {
		return nil, err
	}

	return convertWishlists(dbWishlists), nil
}

// Wishlist is the resolver for the wishlist field.
func (r *queryResolver) Wishlist(ctx context.Context, id string) (*Wishlist, error) {
	wishlistID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return nil, err
	}

	var dbWishlist database.Wishlist
	err = r.DB.WithContext(ctx).
		Preload("Category").
		Preload("Owner").
		Preload("Items.Category").
		Preload("Items.Links").
		First(&dbWishlist, wishlistID).Error

	if err != nil {
		return nil, err
	}

	return convertWishlist(&dbWishlist), nil
}

// Categories is the resolver for the categories field.
func (r *queryResolver) Categories(ctx context.Context) ([]*Category, error) {
	var dbCategories []database.Category
	err := r.DB.WithContext(ctx).Find(&dbCategories).Error
	if err != nil {
		return nil, err
	}

	return convertCategories(dbCategories), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *mutationResolver) Login(ctx context.Context, input Login) (*LoginResponse, error) {
	var user database.User

	if err := r.DB.WithContext(ctx).Model(&database.User{}).Where("email = ?", input.Username).Find(&user); err != nil {
		panic("user doesn't exists")
	}

	password_match := auth.CheckPasswordHash(user.Password, input.Password)

	if !password_match {
		panic("password doesn't match")
	}

	userReturn := convertUser(&user)

	return &LoginResponse{
		Token: "",
		User:  userReturn,
	}, nil

}
*/
